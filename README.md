Основные противоречия заключались в том, какое общее хранилище выбрать. Было два варианта:
1. Redis и использование счетчика запросов по ключу для каждого клиента.
2. Любая БД, в которую будут помещаться данные о вызовах для каждого пользователя.

Первый подход не решает данную задачу (по крайней мере на первый взгляд), так как такое хранение данных не позволяет считать количество вызовов за определенный интервал. Даже если использовать временные клчюи в Redis и обновлять его время жизни при каждом запросе Check, то все-равно не позволит извлечь количество вызовов за последние N секунд.

Поэтому решено было использовать второй подход. В качестве БД взял MongoDB. Можно было бы использовать и Redis, однако, насколько мне известно, там есть сложности с синхронизацией доступа с разных клиентов. (Могу ошибаться, пока нет опыта работы с Redis).

По итогу суть решения такова. При каждом вызове Check удаляются все старые записи до текущего интервала. Считается количество оставшихся+1 (это и есть количество вызовов за последние N секунд). После чего добавляется запись о текущем вызове. Если количество больше K, то возвращается false, иначе true.
Для корректной одновременной работы разных экземпляров приложения были использованы транзакции MongoDB.

Конфиги:
* Данные для монго (в файле .env.example)
* window - N
* maxCalls - K

Запуск приложения
`go run main.go --config=./config/config.yaml`
Можно не указывать путь до файла конфигов, по умолчанию стоит ".config.yaml"

Моделирование вызовов следующее:
Были запущены примерно одновременно три экземпляра для одного пользователя со следующими вызовами:
1. 7 вызовов с интервалом 1 секунда.
2. 2 вызова с интервалом 6 секунд.
N = 10 секунд, K = 5 вызовов.

По итогу должно быть сначала 5 удачных вызовов, после чего остальные вызовы из первого пункта должны вернуть false.
Во втором пункте первый вызов у каждого экземпляра должен вернуть false, так как с первого пункта прошло 6 секунд. Вторые вызовы у двух экзмепляров должны вернуть true, так как за последние 10 секунд были вызваны только первые вызовы второго пункта (первый пункт был больше чем 10 секунд назад). У экземпляра, отработавшего последним, вернется false, так как до этого было 5 обращений во втором пункте меньше чем за 10 секунд.
Вывод программы:  
Экземпляр 1 | Экземпляр 2 | Экземпляр 3
------------|-------------|------------|
Testing UserID: 1 | Testing UserID: 1 | Testing UserID: 1  
**true** | **true** | **true**  
**true** | **true** | false  
false | false | false  
false | false | false  
false | false | false  
false | false | false  
false | false | false  
Testing UserID: 1 | Testing UserID: 1 | Testing UserID: 1  
false | false | false  
**true** | **true** | false  
